{
  "name": "simple_mpi",
  "description": "A simple MPI (Message Passing Interface) implementation for single-machine shared memory communication. This library provides MPI-like functionality for parallel computing within a single machine using POSIX shared memory. It enables efficient inter-process communication through operations like point-to-point messaging, collective operations, and shared memory arrays.",
  "modules": [
    {
      "name": "examples.basic",
      "description": "",
      "structs": null,
      "enums": null,
      "methods": null,
      "submodules": null,
      "attributes": [
        {
          "name": "world.rank() == 0",
          "args": ""
        },
        {
          "name": "world.rank() == 1",
          "args": ""
        },
        {
          "name": "/dev/shm",
          "args": ""
        }
      ],
      "examples": [
        "# Initialize MPI with 4 processes - this will create shared memory and spawn processes\nfn main() {\n    println!(\"Starting process with PID: {}\", std::process::id());\n    let world = World::init(4).unwrap();\n    println!(\"Process {} initialized (PID: {})\", world.rank(), std::process::id());\n\n    \n    if world.rank() == 0 {\n        let message = format!(\"Hello from rank {}\", world.rank());\n        world.send(&message, 1, 0).unwrap();\n        println!(\"Rank {} sent message to rank 1\", world.rank());\n    } else if world.rank() == 1 {\n        let message: String = world.recv(0, 0).unwrap();\n        println!(\"Rank {} received message: {}\", world.rank(), message);\n    }\n\n    \n    if world.rank() == 0 {\n        let data = vec![1, 2, 3, 4];\n        let result = world.broadcast(&data, 0).unwrap();\n        println!(\"Rank {} broadcast data: {:?}\", world.rank(), result);\n    } else {\n        let result: Vec<i32> = world.broadcast(&Vec::new(), 0).unwrap();\n        println!(\"Rank {} received broadcast: {:?}\", world.rank(), result);\n    }\n\n    println!(\"Rank {} preparing for scatter\", world.rank());\n    if world.rank() == 0 {\n        let data: Vec<i32> = (0..world.size()).map(|i| i * 10).collect();\n        println!(\"Rank {} scattering data: {:?}\", world.rank(), data);\n        let piece = world.scatter(Some(&data), 0).unwrap();\n        println!(\"Rank {} scattered and got piece: {}\", world.rank(), piece);\n    } else {\n        println!(\"Rank {} waiting for scatter\", world.rank());\n        let piece: i32 = world.scatter(None, 0).unwrap();\n        println!(\"Rank {} received piece: {}\", world.rank(), piece);\n    }\n\n    println!(\"Rank {} starting gather phase\", world.rank());\n    let local_data = world.rank() * 5;\n    println!(\"Rank {} sending local data: {}\", world.rank(), local_data);\n    let gathered = world.gather(&local_data, 0).unwrap();\n    if world.rank() == 0 {\n        println!(\"Rank {} gathered data: {:?}\", world.rank(), gathered.unwrap());\n    } else {\n        println!(\"Rank {} completed gather\", world.rank());\n    }\n\n    println!(\"Process {} finished\", world.rank());\n    \n    world.destruct();\n}"
      ]
    },
    {
      "name": "examples.shared_array",
      "description": "",
      "structs": [
        {
          "name": "Point",
          "description": "",
          "fields": [
            {
              "name": "x",
              "type": "f32",
              "description": "",
              "visibility": "",
              "attributes": null
            },
            {
              "name": "y",
              "type": "f32",
              "description": "",
              "visibility": "",
              "attributes": null
            },
            {
              "name": "z",
              "type": "f32",
              "description": "",
              "visibility": "",
              "attributes": null
            }
          ],
          "methods": null,
          "visibility": "",
          "attributes": [
            {
              "name": "C",
              "args": ""
            },
            {
              "name": "derive",
              "args": "Debug, Copy, Clone, Pod, Zeroable"
            }
          ],
          "type_params": null,
          "examples": [
            "# Example: Shared Read-only Array with Pod type\nfn main() {\n    let world = World::init(4).unwrap();\n\n    if world.rank() == 0 {\n        let points = vec![\n            Point { x: 1.0, y: 2.0, z: 3.0 },\n            Point { x: 4.0, y: 5.0, z: 6.0 },\n            Point { x: 7.0, y: 8.0, z: 9.0 },\n        ];\n        println!(\"Rank {} creating shared array\", world.rank());\n        \n        let shared = world.shared_readonly_array(Some(&points), 0).unwrap();\n        \n        let view = shared.as_slice();\n        println!(\"Rank {} reading points:\", world.rank());\n        for (i, point) in view.iter().enumerate() {\n            println!(\"  Point {}: ({}, {}, {})\", i, point.x, point.y, point.z);\n        }\n    } else {\n        let shared = world.shared_readonly_array::<Point>(None, 0).unwrap();\n        let view = shared.as_slice();\n\n        for (i, point) in view.iter().enumerate() {\n            assert_eq!(point.x, (i as f32) * 3.0 + 1.0);\n        }\n    }\n\n    world.destruct();\n}"
          ]
        }
      ],
      "enums": null,
      "methods": null,
      "submodules": null,
      "attributes": null,
      "examples": [
        "# Example: Shared Read-only Array with Pod type\nfn main() {\n    let world = World::init(4).unwrap();\n\n    if world.rank() == 0 {\n        let points = vec![\n            Point { x: 1.0, y: 2.0, z: 3.0 },\n            Point { x: 4.0, y: 5.0, z: 6.0 },\n            Point { x: 7.0, y: 8.0, z: 9.0 },\n        ];\n        println!(\"Rank {} creating shared array\", world.rank());\n        \n        let shared = world.shared_readonly_array(Some(&points), 0).unwrap();\n        \n        let view = shared.as_slice();\n        println!(\"Rank {} reading points:\", world.rank());\n        for (i, point) in view.iter().enumerate() {\n            println!(\"  Point {}: ({}, {}, {})\", i, point.x, point.y, point.z);\n        }\n    } else {\n        let shared = world.shared_readonly_array::<Point>(None, 0).unwrap();\n        let view = shared.as_slice();\n\n        for (i, point) in view.iter().enumerate() {\n            assert_eq!(point.x, (i as f32) * 3.0 + 1.0);\n        }\n    }\n\n    world.destruct();\n}"
      ]
    },
    {
      "name": "src",
      "description": "A simple MPI (Message Passing Interface) implementation for single-machine shared memory communication. This library provides MPI-like functionality for parallel computing within a single machine using POSIX shared memory. It enables efficient inter-process communication through operations like point-to-point messaging, collective operations, and shared memory arrays.",
      "structs": [
        {
          "name": "SharedReadOnlyArray",
          "description": "A shared read-only array that can be accessed by all processes. T must be Pod (plain old data) to ensure it contains no pointers/references.",
          "fields": [
            {
              "name": "shmem_idx",
              "type": "usize",
              "description": "",
              "visibility": "",
              "attributes": null
            },
            {
              "name": "_phantom",
              "type": "PhantomData<T>",
              "description": "",
              "visibility": "",
              "attributes": null
            }
          ],
          "methods": [
            {
              "name": "as_slice",
              "description": "Get a slice reference to the array. Safe because T is Pod (contains no pointers/references).",
              "parameters": [],
              "return_type": "&[T]",
              "return_description": "",
              "visibility": "",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": null,
              "examples": [
                "#  Get a slice reference to the array.\nlet shared_array: SharedReadOnlyArray<Point> = ...;\nlet slice: &[Point] = shared_array.as_slice();"
              ]
            }
          ],
          "visibility": "",
          "attributes": null,
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "Pod"
              ],
              "description": "Pod (plain old data) to ensure it contains no pointers/references."
            }
          ],
          "examples": [
            "# Use of SharedReadOnlyArray\nlet shared_array: SharedReadOnlyArray<Point> = ...;\nlet slice: &[Point] = shared_array.as_slice();"
          ]
        },
        {
          "name": "World",
          "description": "The main MPI World structure that manages inter-process communication.",
          "fields": [
            {
              "name": "rank",
              "type": "i32",
              "description": "The rank of the process within the world.",
              "visibility": "private",
              "attributes": null
            },
            {
              "name": "size",
              "type": "i32",
              "description": "The total number of processes in the world.",
              "visibility": "private",
              "attributes": null
            },
            {
              "name": "shmem_idx",
              "type": "usize",
              "description": "Index for the shared memory segment associated with this world.",
              "visibility": "private",
              "attributes": null
            }
          ],
          "methods": [
            {
              "name": "init",
              "description": "Initialize the MPI environment and create a new World.",
              "parameters": [
                {
                  "name": "size",
                  "type": "i32",
                  "description": "The total number of processes to create (must be positive)"
                }
              ],
              "return_type": "Result<Self>",
              "return_description": "A new World instance if initialization succeeds",
              "visibility": "public",
              "is_async": false,
              "is_static": true,
              "attributes": null,
              "type_params": null,
              "examples": [
                "# Initialize the MPI environment and create a new World.\nlet world = World::init(4).unwrap();\nprintln!(\"Process {} of {} initialized\", world.rank(), world.size());\nworld.destruct();"
              ]
            },
            {
              "name": "rank",
              "description": "Get the rank (unique identifier) of the current process.",
              "parameters": [],
              "return_type": "i32",
              "return_description": "An integer representing this process's rank",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": null,
              "examples": [
                "# Get the rank (unique identifier) of the current process.\nlet world = ...;\nlet rank = world.rank();"
              ]
            },
            {
              "name": "size",
              "description": "Get the total number of processes in the World.",
              "parameters": [],
              "return_type": "i32",
              "return_description": "The total number of processes",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": null,
              "examples": [
                "# Get the total number of processes in the World.\nlet world = ...;\nlet size = world.size();"
              ]
            },
            {
              "name": "barrier",
              "description": "Barrier synchronization - blocks until all processes reach this point",
              "parameters": [],
              "return_type": "Result<()>",
              "return_description": "",
              "visibility": "private",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": null,
              "examples": [
                "# Barrier synchronization\nlet world = ...;\nworld.barrier().unwrap();"
              ]
            },
            {
              "name": "send",
              "description": "Send data to a specific rank (blocking until received).",
              "parameters": [
                {
                  "name": "data",
                  "type": "&T",
                  "description": "The data to send (must implement Serialize)"
                },
                {
                  "name": "dest",
                  "type": "i32",
                  "description": "The rank of the destination process"
                },
                {
                  "name": "tag",
                  "type": "i32",
                  "description": "A message identifier (useful for matching specific sends/receives)"
                }
              ],
              "return_type": "Result<()>",
              "return_description": "If the send succeeds",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "Serialize"
                  ],
                  "description": ""
                }
              ],
              "examples": [
                "# Send data to a specific rank (blocking until received).\nlet world = World::init(2).unwrap();\nif world.rank() == 0 {\n    let data = vec![1, 2, 3];\n    world.send(&data, 1, 0).unwrap();\n}\nworld.destruct();"
              ]
            },
            {
              "name": "recv",
              "description": "Receive data from a specific rank.",
              "parameters": [
                {
                  "name": "source",
                  "type": "i32",
                  "description": "The rank of the sending process"
                },
                {
                  "name": "tag",
                  "type": "i32",
                  "description": "The message identifier to match"
                }
              ],
              "return_type": "Result<T>",
              "return_description": "The received and deserialized data",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "DeserializeOwned"
                  ],
                  "description": ""
                }
              ],
              "examples": [
                "# Receive data from a specific rank.\nlet world = World::init(2).unwrap();\nif world.rank() == 1 {\n    let data: Vec<i32> = world.recv(0, 0).unwrap();\n    println!(\"Received: {:?}\", data);\n}\nworld.destruct();"
              ]
            },
            {
              "name": "broadcast",
              "description": "Broadcast data from root rank to all other ranks.",
              "parameters": [
                {
                  "name": "data",
                  "type": "&T",
                  "description": "The data to broadcast (only used by root process)"
                },
                {
                  "name": "root",
                  "type": "i32",
                  "description": "The rank of the broadcasting process"
                }
              ],
              "return_type": "Result<T>",
              "return_description": "The broadcast data (same for all processes)",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "Serialize",
                    "DeserializeOwned",
                    "Clone"
                  ],
                  "description": ""
                }
              ],
              "examples": [
                "# Broadcast data from root rank to all other ranks.\nlet data = if world.rank() == 0 {\n    vec![1, 2, 3]\n} else {\n    vec![]\n};\nlet result = world.broadcast(&data, 0).unwrap();"
              ]
            },
            {
              "name": "scatter",
              "description": "Scatter data from root rank to all ranks.",
              "parameters": [
                {
                  "name": "data",
                  "type": "Option<&[T]>",
                  "description": "Slice of data to scatter (only required on root process)"
                },
                {
                  "name": "root",
                  "type": "i32",
                  "description": "The rank of the scattering process"
                }
              ],
              "return_type": "Result<T>",
              "return_description": "This process's piece of the scattered data",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "Serialize",
                    "DeserializeOwned",
                    "Clone"
                  ],
                  "description": ""
                }
              ],
              "examples": [
                "# Scatter data from root rank to all ranks.\nlet data = if world.rank() == 0 {\n    Some(&[10, 20, 30, 40][..])\n} else {\n    None\n};\nlet my_number = world.scatter(data, 0).unwrap();\nprintln!(\"Process {} got {}\", world.rank(), my_number);"
              ]
            },
            {
              "name": "gather",
              "description": "Gather data from all ranks to root rank.",
              "parameters": [
                {
                  "name": "data",
                  "type": "&T",
                  "description": "The local data to contribute to the gather"
                },
                {
                  "name": "root",
                  "type": "i32",
                  "description": "The rank of the gathering process"
                }
              ],
              "return_type": "Result<Option<Vec<T>>>",
              "return_description": "Vector of gathered data (only on root process)",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "Serialize",
                    "DeserializeOwned",
                    "Clone"
                  ],
                  "description": ""
                }
              ],
              "examples": [
                "# Gather data from all ranks to root rank.\nlet result = world.gather(&world.rank(), 0).unwrap();\nif world.rank() == 0 {\n    println!(\"Gathered: {:?}\", result.unwrap());\n}"
              ]
            },
            {
              "name": "destruct",
              "description": "Explicitly clean up MPI resources and synchronize process shutdown.",
              "parameters": [],
              "return_type": "()",
              "return_description": "",
              "visibility": "public",
              "is_async": false,
              "is_static": false,
              "attributes": null,
              "type_params": null,
              "examples": [
                "# Explicitly clean up MPI resources and synchronize process shutdown.\nlet world = World::init(2).unwrap();\n//... use the world for communication ...\nworld.destruct(); // Clean up resources"
              ]
            }
          ],
          "visibility": "",
          "attributes": null,
          "type_params": [],
          "examples": [
            "# Examples \n// Basic point-to-point communication:\nlet world = World::init(2).unwrap();\nif world.rank() == 0 {\n    // Send data from process 0 to process 1\n    world.send(&42, 1, 0).unwrap();\n} else {\n    // Receive data in process 1\n    let data: i32 = world.recv(0, 0).unwrap();\n    println!(\"Received: {}\", data);\n}\nworld.destruct(); \n\n// Collective operation (broadcast):\nlet world = World::init(4).unwrap();\nlet data = if world.rank() == 0 { vec![1, 2, 3] } else { vec![] };\nlet result = world.broadcast(&data, 0).unwrap();\nassert_eq!(result, vec![1, 2, 3]);\nworld.destruct();"
          ]
        }
      ],
      "enums": [
        {
          "name": "MPIError",
          "description": "",
          "variants": [
            {
              "name": "InvalidRank",
              "fields": null,
              "description": "Invalid rank provided."
            },
            {
              "name": "CommunicationError",
              "fields": null,
              "description": "Communication error occurred."
            },
            {
              "name": "InitError",
              "fields": null,
              "description": "Error during initialization."
            },
            {
              "name": "SerializationError",
              "fields": null,
              "description": "Serialization error occurred."
            },
            {
              "name": "SharedMemoryError",
              "fields": null,
              "description": "Error related to shared memory."
            },
            {
              "name": "ProcessError",
              "fields": null,
              "description": "Error related to processes."
            }
          ],
          "methods": null,
          "visibility": "",
          "attributes": [
            {
              "name": "derive",
              "args": "Error, Debug"
            }
          ],
          "type_params": null
        }
      ],
      "methods": null,
      "submodules": null,
      "attributes": [
        {
          "name": "crate-level",
          "args": ""
        },
        {
          "name": "features",
          "args": ""
        },
        {
          "name": "quick_start",
          "args": ""
        },
        {
          "name": "architecture",
          "args": ""
        },
        {
          "name": "error_handling",
          "args": ""
        }
      ],
      "examples": [
        "# Initialize the MPI environment and create a new World.\nlet world = World::init(4).unwrap();\nprintln!(\"Process {} of {} initialized\", world.rank(), world.size());\nworld.destruct();"
      ]
    }
  ],
  "examples": [
    "# Initialize the MPI environment and create a new World.\nlet world = World::init(4).unwrap(); \nprintln!(\"Process {} of {} initialized\", world.rank(), world.size()); \nworld.destruct(); "
  ]
}